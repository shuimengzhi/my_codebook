[TOC]
#锁
##读写锁
无论何时, 只要有多个查询需要同一时刻修改同一部分数据, 就会产生并发控制的问题, MySQL采用`读写锁`来解决这类问题

- `读锁` (又称共享锁): 是共享的, 或者说互不阻塞, 允许不同客户在同一时刻读取同一个资源
- `写锁` (又称排他锁): 是排他的, 会阻塞其他的写锁和读锁
## 乐观锁、悲观锁
 - `乐观锁`: 认为数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回错误信息，让用户决定如何去做 ( 例如: MVCC )
 - `悲观锁`: 每次获取和更改数据时，都要加锁，防止其他事务更改 ( 例如select...for update ）
 ## 锁的颗粒度
 为了提高并发性, 锁住的数据应该更精准, 锁定的资源更少, 于是锁又分为表锁和行级锁


- `表锁`: 锁开销最小, 锁定整张表
- `行级锁`: 锁开销最大, 可以最大程度支持并发处理, 锁定表中的某一行
## 事务
- 事务就是一组原子性的SQL, 事务内的语句要么全部执行成功, 要么全部执行失败, 有如下四个特征, 又称为`ACID`:

- 原子性 (atomicity): 一个事务是一个不可分割的最小工作单元, 要么全部成功, 要么全部失败
- 一致性 (consistency): 从一个一致性状态到另一个一致性状态, 中间修改不会提交到数据库
- 隔离性 (isolation): 一个事务所做的修改在最终提交以前, 对于其他事务是不可见的
- 持久性 (durability): 事物一旦提交, 就会永久保存到数据库中
##事务的隔离级别
隔离级别规定了一个事务中所做的修改, 哪些在事务内和事物间是可见的, 哪些是不可见的, 较低级别的隔离通常可以执行更高的并发, 系统开销也更低:

- 未提交读(READ UNCOMMITED): 事务中的修改, 即使没有提交, 也对其他事务可见, 性能不比其他级别好太多, 实际很少使用
- 提交读(READ COMMITED): 一个事务从开始到提交之前, 所做的任何修改对其他事务都是不可见的
- 可重复读(REPEATABLE READ): MySQL默认事务隔离级别, 同一个事务中多次读取同样记录的结果是一致的
- 可串行化(SERIALIZABLE): 最高级别的隔离, 强制事务串行执行, 性能差
##各隔离级别的问题
先来了解一下隔离级别导致的问题:

- `脏读`(Dirty Read): 事务可以读取未提交的数据
- `不可重复读`(nonrepeatable read): 两次执行同样的查询, 可能会得到不一样的结果
- `幻读`(Phantom Read): 当某个事务在读取某个范围内记录时, 另一个事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时, 会产生幻行
##隔离级别对应的问题
![](./read.jpg)

##对应解决办法
##解决脏读、不可重复读
`可重复读`这一隔离级别默认解决了脏读和不可重复读, 保证了同一事务多次读取同样记录结果是一致的

##解决幻读
先要了解`MVCC`的概念, `MVCC`是行级锁的一个变种, 但是它在很多情况下避免了
加锁操作, 因此开销更低

>原理 : 通过在每行记录后面保存两个隐藏的列来实现, 这两个列, 一个保存了行的创建时间, 一个保存行的过期时间(或删除时间), 存储的不是时间, 是系统版本号(system version number), 每开启一个新的事务, 系统版本号都会自动递增, 事务开始时刻的系统版本号会作为事务的版本号, 用来和查询到的每行记录的版本号进行比较

两种读取方式:

- 当前读:
   ``` 
   select...lock in share mode (共享读锁)
    select...for update
    update , delete , insert
    ```
　　读取的是最新版本, 并且对读取的记录加锁, 阻塞其他事务同时改动相同记录, 避免出现安全问题

- 快照读: 单纯的select操作

然后理解一下三种锁:

- 行锁(record): 对表中的记录加锁
- 间隙锁(gap-key): 封锁索引记录中的间隔, 如果列具有唯一索引, 则不会加间隙锁
- 临键锁(next-key): 行锁与间隙锁的组合, 它的封锁范围, 既包含索引记录, 又包含索引区间

InnoDB采用间隙锁+MVCC去解决幻读问题的：

- 在当前读中, 用间隙锁解决幻读问题
- 在快照读中, 会用MVCC解决幻读问题